import tkinter as tk
from tkinter import ttk
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import matplotlib.pyplot as plt
import numpy as np
import sympy as sp
from sympy.parsing.sympy_parser import parse_expr

#BUTTON/GRAPHING FUNCTION INFO--------------------------------------------------------------------------------
x, y = sp.symbols('x y')

#IMPORTANT DEFINITIONS----------------------------------------------------------------------------------------
def classify_critical_point(f, g, point):

    # Compute bordered Hessian components
    g_x = sp.diff(g, x)
    g_y = sp.diff(g, y)
    
    f_xx = sp.diff(f, x, 2)
    f_xy = sp.diff(f, x, y)
    f_yy = sp.diff(f, y, 2)
    
    # Construct bordered Hessian matrix
    H_bordered = sp.Matrix([
        [0,    g_x,   g_y],
        [g_x,  f_xx,  f_xy],
        [g_y,  f_xy,  f_yy]
    ])
    
    # Evaluate at the critical point
    H_eval = H_bordered.subs({x: point[0], y: point[1]})
    det_H = sp.det(H_eval)
    
    # Classify based on determinant sign
    try:
        det_val = float(det_H)
    except:
        return "Inconclusive (evaluation error)"
    
    if abs(det_val) < 1e-10:
        return "Inconclusive"
    elif det_val < 0:
        return "Minimum"
    else:  # det_val > 0
        return "Maximum"

def on_button_click():
    
    output_box.config(state="normal")
    output_box.delete("1.0", tk.END)
    output_box.config(state="disabled")

    # Clear previous plots
    ax2d.clear()
    ax3d.clear()

    h = float(current_value_var.get())
    k = float(current1_value_var.get())
    R = float(current2_value_var.get())

    # Recalculate and draw the circle
    X, Y = np.meshgrid(np.linspace(-5, 5, 100), np.linspace(-5, 5, 100))
    Z = (X - h)**2 + (Y - k)**2 - R**2
    ax2d.contour(X, Y, Z, levels=[0], colors='blue')
    ax2d.axis("equal")
    ax2d.set_title("2D Plot")

    # ---- Circle on surface ----
    t = np.linspace(0, 2*np.pi, 200)
    circle_x = h + R * np.cos(t)
    circle_y = k + R * np.sin(t)

    # Get typed equation
    expr = equation_var.get()
    expr = expr.replace("^", "**")    # allow ^ for power

    try:
        circle_z = eval(expr, {"x": circle_x, "y": circle_y, "np": np})
    except:
        circle_z = np.zeros_like(circle_x)

    ax3d.plot(circle_x, circle_y, circle_z, color="red", linewidth=3, label="Circle on surface")
    ax3d.set_title(f"3D: f(x,y) = {expr}")

    # ---- Circle on floor (z=0) ----
    circle_z_floor = np.zeros_like(circle_x)
    ax3d.plot(circle_x, circle_y, circle_z_floor, color="blue", linewidth=3, linestyle="--", label="Circle on floor")

    # Prepare grid
    X3, Y3 = np.meshgrid(np.linspace(-5, 5, 50),
                         np.linspace(-5, 5, 50))

    # Safely evaluate Z
    try:
        Z3 = eval(expr, {"x": X3, "y": Y3, "np": np})
        ax3d.plot_surface(X3, Y3, Z3, cmap="viridis")
    except Exception as e:
        ax3d.text2D(0.1, 0.9, f"ERROR:\n{e}",
                    transform=ax3d.transAxes)
    
    canvas2d.draw()
    canvas3d.draw()

def on_button_click1():
    output_box.config(state="normal")
    output_box.delete("1.0", tk.END)
    
    try:
        # Get the equation and constraint parameters
        expr_str = equation_var.get().replace("^", "**")
        h = float(current_value_var.get())
        k = float(current1_value_var.get())
        R = float(current2_value_var.get())
        
        # Put expression into a sympy expression
        f = parse_expr(expr_str, local_dict={'x': x, 'y': y})
        
        # Define the constraint g(x,y) = (x-h)^2 + (y-k)^2 - R^2 = 0
        g = (x - h)**2 + (y - k)**2 - R**2
        
        print_to_box(f"Surface Function: f(x,y) = {f}")
        print_to_box(f"Constraint: g(x,y) = (x-{h})^2 + (y-{k})^2 - {R}^2 = 0")
        
        # gradients
        f_x = sp.diff(f, x)
        f_y = sp.diff(f, y)
        g_x = sp.diff(g, x)
        g_y = sp.diff(g, y)
        
        # Lagrange multiplier 
        lam = sp.Symbol('lambda')
        
        # System of equations: 
        eq1 = sp.Eq(f_x, lam * g_x)
        eq2 = sp.Eq(f_y, lam * g_y)
        eq3 = sp.Eq(g, 0)
        
        # Solve the system
        solutions = sp.solve([eq1, eq2, eq3], [x, y, lam], dict=True)
        
        if not solutions:
            print_to_box("No critical points found!")
            output_box.config(state="disabled")
            return
        
        print_to_box("Found " + str(len(solutions)) + " critical point(s):\n")
        
        # Evaluate and classify each critical point
        critical_points = []
        for i, sol in enumerate(solutions):
            x_val = float(sol[x].evalf())
            y_val = float(sol[y].evalf())
            
            # Check if point satisfies constraint
            constraint_check = (x_val - h)**2 + (y_val - k)**2 - R**2
            if abs(constraint_check) > 1e-6:
                continue  # Skip if not on constraint
            
            f_val = float(f.subs({x: x_val, y: y_val}).evalf())
            
            # Classify the point
            classification = classify_critical_point(f, g, (x_val, y_val))
            
            critical_points.append((x_val, y_val, f_val, classification))
            
            print_to_box(f"Point {i+1}:")
            print_to_box(f"  (x, y) = ({x_val:.4f}, {y_val:.4f})")
            print_to_box(f"  f(x, y) = {f_val:.4f}")
            print_to_box(f"  Classification: {classification}\n")
        
        # Find global max and min
        if critical_points:
            f_values = [pt[2] for pt in critical_points]
            max_val = max(f_values)
            min_val = min(f_values)
            
            print_to_box("--- Summary ---")
            print_to_box(f"Global Maximum: f = {max_val:.4f}")
            print_to_box(f"Global Minimum: f = {min_val:.4f}")
            
            # Plot critical points on 2D graph
            for pt in critical_points:
                if pt[3] == "Maximum":
                    ax2d.plot(pt[0], pt[1], 'ro', markersize=10, label='Max')
                elif pt[3] == "Minimum":
                    ax2d.plot(pt[0], pt[1], 'go', markersize=10, label='Min')
                else:
                    ax2d.plot(pt[0], pt[1], 'yo', markersize=10, label='Saddle')
            
            # Plot critical points on 3D graph
            for pt in critical_points:
                if pt[3] == "Maximum":
                    ax3d.scatter([pt[0]], [pt[1]], [pt[2]], c='red', s=100, marker='o')
                elif pt[3] == "Minimum":
                    ax3d.scatter([pt[0]], [pt[1]], [pt[2]], c='green', s=100, marker='o')
                else:
                    ax3d.scatter([pt[0]], [pt[1]], [pt[2]], c='yellow', s=100, marker='o')
            
            canvas2d.draw()
            canvas3d.draw()
        
    except Exception as e:
        print_to_box(f"ERROR: {str(e)}")
        import traceback
        print_to_box(traceback.format_exc())
    
    output_box.config(state="disabled")
    # "on_button_click1" will find the critical points inside the constrained circle, on the surface of F, then it will use "classify_critical_points" to determine if the points are maximum, minimum, and saddle points then print findings to box

def print_to_box(*args):
    text = " ".join(str(a) for a in args) + "\n"
    output_box.config(state="normal")
    output_box.insert(tk.END, text)
    output_box.see(tk.END)
    output_box.config(state="disabled")

#MAIN WIDGET -------------------------------------------------------------------------------------------------
# Main window (root)
root = tk.Tk()
root.title("Multivariable Calculus Unit 14.7 - Optimization With Constraints")
root.geometry("1200x600")         # window size (optional)
root.minsize(420, 240)

# Main frame
container = ttk.Frame(root)
container.pack(fill="both", expand=True, padx=12, pady=8)

# Left frame
left_frame = ttk.Frame(container, width=150)
left_frame.pack(side="left", fill="y", padx=(0, 8))
left_frame.pack_propagate(False)

# Top Box in left frame + containing sliders & text box
tbox = ttk.Frame(left_frame, relief="solid")
tbox.pack(side='top', fill = 'x', padx=10, pady=5)
tbox.pack_propagate(True)

text = ttk.Label(tbox, text="Circle Equation:")
text.pack(padx=10, pady=(10, 0))

stext = ttk.Label(tbox, text="X Value:")
stext.pack(padx=10, pady=(10, 0))

slider = ttk.Scale(tbox, from_=-10, to=10, orient="horizontal")
slider.set(0)   # default value

slider.pack(padx=10, pady=(10, 10), fill="x")

current_value_var = tk.StringVar(value=str(int(slider.get())))
def on_slider_move(event):
    current_value_var.set(str(int(float(slider.get()))))

slider.bind("<ButtonRelease-1>", on_slider_move)
slider_value_label = ttk.Label(tbox, textvariable=current_value_var)
slider_value_label.pack(anchor="e", padx=10)
#----------------------------------------------------------------
stext1 = ttk.Label(tbox, text="Y Value:")
stext1.pack(padx=10, pady=(10, 0))

slider1 = ttk.Scale(tbox, from_=-10, to=10, orient="horizontal")
slider1.set(0)   # default value

slider1.pack(padx=10, pady=(10, 10), fill="x")

current1_value_var = tk.StringVar(value=str(int(slider1.get())))
def on_slider1_move(event):
    current1_value_var.set(str(int(float(slider1.get()))))

slider1.bind("<ButtonRelease-1>", on_slider1_move)
slider1_value_label = ttk.Label(tbox, textvariable=current1_value_var)
slider1_value_label.pack(anchor="e", padx=10)
#----------------------------------------------------------------
stext2 = ttk.Label(tbox, text="R Value:")
stext2.pack(padx=10, pady=(10, 0))

slider2 = ttk.Scale(tbox, from_=0, to=10, orient="horizontal")
slider2.set(5)   # default value

slider2.pack(padx=10, pady=(10, 10), fill="x")

current2_value_var = tk.StringVar(value=str(int(slider2.get())))
def on_slider2_move(event):
    current2_value_var.set(str(int(float(slider2.get()))))

slider2.bind("<ButtonRelease-1>", on_slider2_move)
slider2_value_label = ttk.Label(tbox, textvariable=current2_value_var)
slider2_value_label.pack(anchor="e", padx=10)

# Main function text box
equation_var = tk.StringVar()

eq_label = ttk.Label(tbox, text="Enter f(x, y):")
eq_label.pack(padx=10, pady=(10, 0))

eq_entry = ttk.Entry(tbox, textvariable=equation_var)
eq_entry.pack(padx=10, pady=(11,12), fill="x")


# Bottom box inside left_frame containing the buttons
box = ttk.Frame(left_frame, relief="solid")
box.pack(side='bottom', fill = 'x', padx=10, pady=10)
box.pack_propagate(True)

button = ttk.Button(box, text="Refresh Graphs", command=on_button_click)
button.pack(pady=(5, 5), padx=10, fill="x")

button1 = ttk.Button(box, text="Find Points", command=on_button_click1)
button1.pack(pady=(5, 5), padx=10, fill="x")

# Right Main Frame
right_frame = ttk.Frame(container)
right_frame.pack(side="left", fill="both", expand=True)

# Right Top Containing Frame
top_of_right_frame = ttk.Frame(right_frame)
top_of_right_frame.pack(side="top", fill="both", expand=True)

# Box for the bottom of right frame
rbox = ttk.Frame(right_frame, height=170, relief="solid")
rbox.pack(side='bottom', fill='x', padx=0, pady=10)
rbox.pack_propagate(False)

return_box = ttk.Label(rbox, text="Points appear here:")
return_box.pack(padx=10, pady=(10, 0))


# Output box in bottom right
output_box = tk.Text(rbox, height=10, wrap="word", state="disabled")
output_box.pack(fill="both", expand=True, padx=0, pady=5)


#2d & 3d graphs -----------------------------------------------------------------------------------------------

# --- 2D Plot ---
h = float(current_value_var.get())
k = float(current1_value_var.get())
R = float(current2_value_var.get())

f = lambda x, y: (x-h)**2 + (y-k)**2 - R**2
fig2d = plt.Figure(figsize=(4, 3))
ax2d = fig2d.add_subplot(111)
X, Y = np.meshgrid(np.linspace(-5, 5, 100), np.linspace(-5, 5, 100))
Z = f(X, Y)
ax2d.contour(X, Y, Z, levels=[0], colors='blue')
ax2d.set_title("2D Plot")
ax2d.axis("equal")

canvas2d = FigureCanvasTkAgg(fig2d, master=top_of_right_frame)
canvas2d.draw()
canvas2d.get_tk_widget().pack(side="left", fill="both", expand=True, pady=5)

# --- 3D Plot ---
fig3d = plt.Figure(figsize=(4, 3))
ax3d = fig3d.add_subplot(111, projection="3d")

# Create grid
X = np.linspace(-5, 5, 50)
Y = np.linspace(-5, 5, 50)
X, Y = np.meshgrid(X, Y)

# Get the equation string
expr = equation_var.get().replace("^", "**")

# Safely evaluate equation
try:
    Z = eval(expr, {"x": X, "y": Y, "np": np})
except Exception as e:
    Z = np.zeros_like(X)   # fallback surface
    print("Equation error:", e)

# Plot surface
ax3d.plot_surface(X, Y, Z, cmap="viridis")
ax3d.set_title(f"3D Plot: f(x,y) = {expr}")

canvas3d = FigureCanvasTkAgg(fig3d, master=top_of_right_frame)
canvas3d.draw()
canvas3d.get_tk_widget().pack(side="right", fill="both", expand=True, pady=5)

#--------------------------------------------------------------------------------------------------------------
# Start the GUI event loop

root.mainloop()


